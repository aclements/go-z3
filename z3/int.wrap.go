// Generated by genwrap.go. DO NOT EDIT

package z3

import "runtime"

/*
#cgo LDFLAGS: -lz3
#include <z3.h>
#include <stdlib.h>
*/
import "C"

// Eq returns an expression that is true if l and r are equal.
func (l Int) Eq(r Int) Bool {
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_eq(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapValue(ctx, cexpr))
}

// NE returns an expression that is true if l and r are not equal.
func (l Int) NE(r Int) Bool {
	return l.ctx.Distinct(l, r)
}

// Div returns the floor of l / r.
//
// If r is 0, the result is unconstrained.
//
// Note that this differs from Go division: Go rounds toward zero
// (truncated division), whereas this rounds toward -inf.
func (l Int) Div(r Int) Int {
	// Generated from int.go:70.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_div(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Int(wrapValue(ctx, cexpr))
}

// Mod returns modulus of l / r.
//
// The sign of the result follows the sign of r.
func (l Int) Mod(r Int) Int {
	// Generated from int.go:76.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_mod(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Int(wrapValue(ctx, cexpr))
}

// Rem returns remainder of l / r.
//
// The sign of the result follows the sign of l.
func (l Int) Rem(r Int) Int {
	// Generated from int.go:82.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_rem(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Int(wrapValue(ctx, cexpr))
}

// ToReal returns an expression that converts l to sort Real.
func (l Int) ToReal() Real {
	// Generated from int.go:86.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_int2real(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Real(wrapValue(ctx, cexpr))
}

// ToBV converts l to a bit-vector of width bits.
func (l Int) ToBV(bits int) BV {
	// Generated from int.go:90.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_int2bv(ctx.c, C.unsigned(bits), l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapValue(ctx, cexpr))
}

// Add returns the sum l + r[0] + r[1] + ...
func (l Int) Add(r ...Int) Int {
	// Generated from intreal.go:12.
	ctx := l.ctx
	cargs := make([]C.Z3_ast, len(r)+1)
	cargs[0] = l.c
	for i, arg := range r {
		cargs[i+1] = arg.c
	}
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_add(ctx.c, C.uint(len(cargs)), &cargs[0])
	})
	runtime.KeepAlive(&cargs[0])
	return Int(wrapValue(ctx, cexpr))
}

// Mul returns the product l * r[0] * r[1] * ...
func (l Int) Mul(r ...Int) Int {
	// Generated from intreal.go:16.
	ctx := l.ctx
	cargs := make([]C.Z3_ast, len(r)+1)
	cargs[0] = l.c
	for i, arg := range r {
		cargs[i+1] = arg.c
	}
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_mul(ctx.c, C.uint(len(cargs)), &cargs[0])
	})
	runtime.KeepAlive(&cargs[0])
	return Int(wrapValue(ctx, cexpr))
}

// Sub returns l - r[0] - r[1] - ...
func (l Int) Sub(r ...Int) Int {
	// Generated from intreal.go:20.
	ctx := l.ctx
	cargs := make([]C.Z3_ast, len(r)+1)
	cargs[0] = l.c
	for i, arg := range r {
		cargs[i+1] = arg.c
	}
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_sub(ctx.c, C.uint(len(cargs)), &cargs[0])
	})
	runtime.KeepAlive(&cargs[0])
	return Int(wrapValue(ctx, cexpr))
}

// Neg returns -l.
func (l Int) Neg() Int {
	// Generated from intreal.go:24.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_unary_minus(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Int(wrapValue(ctx, cexpr))
}

// Exp returns lá¶ .
func (l Int) Exp(r Int) Int {
	// Generated from intreal.go:28.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_power(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Int(wrapValue(ctx, cexpr))
}

// LT returns l < r.
func (l Int) LT(r Int) Int {
	// Generated from intreal.go:32.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_lt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Int(wrapValue(ctx, cexpr))
}

// LE returns l <= r.
func (l Int) LE(r Int) Int {
	// Generated from intreal.go:36.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_le(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Int(wrapValue(ctx, cexpr))
}

// GT returns l > r.
func (l Int) GT(r Int) Int {
	// Generated from intreal.go:40.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_gt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Int(wrapValue(ctx, cexpr))
}

// GE returns l >= r.
func (l Int) GE(r Int) Int {
	// Generated from intreal.go:44.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_ge(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Int(wrapValue(ctx, cexpr))
}
